Диалоги. Часть 1.
Сначала терминология и базовые понятия.
Процесс общения актора и NPC будем называть беседой или разговором. НЕ диалогом, почему - дальше будет ясно.
Окно, в котором процесс общения происходит, соответственно будем называть окном разговора, беседы или чатом.
С точки зрения игры разговор заключается в том, что открывается это окно, а собеседник-NPC удерживается от убегания специальной скриптовой схемой.
Окончание разговора - это закрытие окна.
Нас же больше интересует разговор, как обмен фразами. С этой точки зрения разговор заключается в инициировании отдельных диалогов. Итак, диалог - это отдельный именованный набор фраз, объединённых в граф. Граф направленный, у него есть корневая вершина-фраза, которая является первой в диалоге. Кто какую фразу скажет определяется тем, кто начинает этот диалог. Далее по ходу собеседники просто чередуются. Правила выбора фраз из возможных ветвлений я опишу дальше. Диалог заканчивается, когда сказана последняя фраза в ветке, т.е. такая, у которой нет никаких следующих фраз. Заканчивается диалог, но не разговор!
Разговор может содержать несколько таких диалогов, которые делятся на две категории: стартовые диалоги (иначе называются приветственные) и диалоги актора (иначе называются темы для разговора).
Стартовый диалог может быть только один.
Уточнение
Если точнее, один можно задавать. Ещё один с именем "hello_dialog" прописывается движком. Если задан ваш диалог, то сработает он, если не задан или отключён предусловием, то сработает "hello_dialog". Если предусловием отключить и его, то будет попросу пустое окно, и никакого общения не начнётся.
С этого диалога начинается разговор. Первую фразу в нём говорит собеседник-NPC. Стартовый диалог одноразовый. Когда он заканчивается, то в пределах текущего разговора (т.е. пока открыто окно разговора) начать его заново будет невозможно. Это не есть плохо, просто надо понимать, что в этом диалоге не надо размещать ничего из того, что может повторяться. Обычно там стоят фразы типа "привет", которые и впрямь надо говорить не больше одного раза.
Когда стартовый диалог заканчивается, появляется возможность начать один из диалогов актора, которые ещё иначе называют темами для разговора. Технически эти диалоги не отличаются от стартового, но отличаются в том что:
- первую фразу в них говорит актор (значит, меняется и очередность фраз)
- таких диалогов может быть несколько
- по окончании диалог можно повторить
Разговор можно закончить, только закрыв окно. Окончание очередного диалога не означает автоматически закрытие окна. Его можно закрыть вручную, кнопочками "Esc" и "F", а можно скриптовыми командами. Для второго варианта в оригинальной игре актору приписан специальный диалог "actor_break_dialog" с одной единственной фразой "До встречи!" и действием dialogs.break_dialog, которое скриптово остановит разговор.
Ещё раз вкратце!
Разговор заключается в открытии окна разговора. При этом NPC атоматом начинает говорить первую фразу из стартового диалога. По окончании стартового диалога актор выбирает любой из доступных диалогов актора, по его окончании опять может выбрать любой из диалогов актора и так до тех пор, пока не будет закрыто тем или иным способом окно разговора.

Теперь всё в подробностях.

Набор диалогов, доступных при разговоре с персонажем, прописывается в его профиле (о профилях см. пару постов выше). Это выглядит так:

<xml>
    <specific_character id="specific_character_profile_name" no_random = "0" team_default = "1">
        ...
        <start_dialog>start_dialog_name</start_dialog>
        <actor_dialog>actor_dlg_1</actor_dialog>
        <actor_dialog>actor_dlg_2</actor_dialog>
    </specific_character>
</xml>

Где start_dialog_name - имя стартового диалога, actor_dlg_1 и actor_dlg_2 - имена диалогов актора. Указанный здесь стартовый диалог можно впоследствии заменить скриптами, а набор диалогов актора можно также скриптами дополнить. Повторюсь, что стартовый диалог может быть только один. Прописать можно несколько, но работать будет только самый первый. Если не установлен никакой, то движок устанавливает диалог hello_dialog. Если заглянуть в него, то увидим всего две фразы: приветствие и просьба о помощи, если сталкер ранен.
Все диалоги должны быть заранее зарегистрированы в XML файлах. Все XML файлы с диалогами должны быть перечислены в файле system.ltx в разделе [dialogs] в параметре files.

Описание отдельного диалога в XML файле выглядит так:

<?xml version="1.0" encoding="windows-1251" ?>
<game_dialogs>
    <dialog id="dialog1" priority="123" caption="theme_title">
        <precondition>module_name1.prec_func1</precondition>
        <has_info>info_portion1</has_info>
        <dont_has_info>info_portion2</dont_has_info>
        <phrase_list>
            <phrase id="0">
                <text>Starting_phrase_text</text>
                <next>1_1</next>
                <next>1_2</next>
                <next>1_3</next>
            </phrase>
            <phrase id="1_1">
                <has_info>info_portion2</has_info>
                <text>Level_1_phrase_text_v1</text>
            </phrase>
            <phrase id="1_2">
                <dont_has_info>info_portion3</dont_has_info>
                <text>Level_1_phrase_text_v2</text>
                <next>2</next>
            </phrase>
            <phrase id="1_3">
                <precondition>module_name6.prec_func11</precondition>
                <text>Level_1_phrase_text_v3</text>
                <next>0</next>
            </phrase>
            <phrase id="2">
                <text>Level_2_phrase_text</text>
                <give_info>info_portion_5</give_info>
                <disable_info>info_portion_6</disable_info>
            </phrase>
        </phrase_list>
    </dialog>
    <dialog id="dialog2">
        <precondition>...</precondition>
        <has_info>...</has_info>
        <dont_has_info>...</dont_has_info>
        <init_func>module_name3.init_func_name</init_func>
    </dialog>
<game_dialogs>

Атрибуты тега dialog:
id - задаёт имя диалога, на которое ссылается тег start_dialog или actor_dialog в профиле персонажа.
priority - произвольное целое число. Имеет смысл только для диалогов актора. Диалоги сортируются по этому признаку в окне выбора.
caption - заголовок диалога. Имеет смысл только для диалога актора. Выбор одного из нескольких диалогов актора - это как бы выбор темы для разговора, а атрибут caption задаёт название этой темы. Это название и будет отображаться в списке диалогов, доступных для выбора. Если этот атрибут не задан, то заголовок устанавливается равным тексту первой фразы диалога, имеющей идентификатор "0".

Теги has_info, dont_has_info и precondition позволяют задавать условия доступности диалога по наличию/отсутствию инфопорции или скриптовой функцией. Функция должна иметь вид:

function dialog_prec(first_speaker, second_speaker, dlg_id)
    ...
    return true/false
end

здесь:
dlg_id - идентификатор диалога, для которого проверяется предусловие
first_speaker - тот, кто будет говорить первым. Если это стартовый диалог, то это NPC, если диалог актора, то актор.
second_speaker - соответственно, второй собеседник
Предусловия вызываются всякий раз, когда заново строится список диалогов. В пределах одного разговора список тем может меняться.

Граф фраз можно инициализировать одним из двух способов - прямо в XML с помощью тега phrase_list (в примере выше - dialog1) или скриптовой функцией инициализации (в примере - dialog2).
Важное разъяснение относительно инициализации диалогов.
Независимо от способа, которым был инициализирован конкретный диалог, это происходит один раз для этого диалога за всё время запуска игры. Вот к примеру, если один и тот-же диалог прописан двум разным персонажам, то он будет инициализирован при первом разговоре с тем персонажем, с которым актор заговорил первым. При разговоре со вторым персонажем будет уже использован тот-же самый диалог, с тем же графом фраз. Более того, если вы перезагрузили игру (но не вышли из программы), то диалог будет использован с прошлой игры и уже не будет заново инициализирован ни для кого из этих двух NPC.
Самое важное следствие из сказанного - динамически строить граф фраз в зависимости от ситуации не получится. Более того, надо тщательно следить за тем, чтобы ненароком не построить граф фраз иначе, чем в прошлый раз. В противном случае можно нарваться на абсолютно непредсказуемые ошибки, которые зависят от таких вещей, как запустили ли вы программу только что или это уже второй и далее сейв и с каким из NPC вы заговорили раньше и пр. в этом роде. Это будет невозможно отловить и отладить.
О том, что можно, поговорим в самом конце.

Инициализация с помощью тега phrase_list показана в примере для dialog1. Граф диалога, который строится этим фрагментом, показан на рис.
Картинка

Возможные атрибуты и теги для отдельной фразы:
Атрибут "id" - задаёт идентификатор фразы. Фраза с идентификатором "0" будет первой в диалоге. За исключением этой фразы идентификатор может быть произвольным текстом.
тег "next" - задаёт идентификатор фразы, которую можно сказать после текущей. Таких тегов может быть несколько, что задаст возможные ветвления. Актору даётся возможность выбрать фразу, а NPC выбирает фразу случайным образом. Выбирать что актор, что NPC могут только фразы, прошедшие проверку по предусловиям.
тег "text" - задаёт текст фразы. Как и большинство других текстовых элементов допускает трансляцию в локализованный текст (см. описание функции game.translate_string()). Фразе можно сопоставить звук. Для этого в каталог sounds\characters_voice\dialogs\ нужно поместить звук с именем, как у тега "text" и расширением "*.ogg". Но говорить будут только NPC. Актор по жизни немой =)
теги has_info, dont_has_info и precondition задают предусловия аналогично как для диалога в целом. Но функция для предусловия фразы должна иметь следующий вид:

function phrase_prec(first_speaker, second_speaker, dialog_id, prev_phrase_id, phrase_id)
    ...
    return true/false
end

здесь
phrase_id - идентификатор фразы, для которой запрашивается предусловие
first_speaker - кто говорит эту фразу,
second_speaker - соответственно, другой собеседник
dialog_id - имя диалога
prev_phrase_id - фраза, которая была перед текущей
Все предусловия проверяются непосредственно после того, как была сказана предыдущая фраза. Хотя полный список возможных фраз в соответствии с уже построенным графом фраз изменить нельзя, но можно часть фраз заблокировать, обеспечивая таким образом некоторую вариабельность.
тег action позволяет задать функцию, которая выполнится после того, как будет сказана фраза. Функция действия должна иметь вид:

function phrase_action(first_speaker, second_speaker, dialog_id, phrase_id)
    ...
end

здесь
first_speaker - кто говорит эту фразу,
second_speaker - соответственно, другой собеседник
dialog_id - имя текущего диалога
phrase_id - имя сказанной фразы
Теги "give_info" и "disable_info" позволяют включать и выключать указанные инфопорции.
Также имеется тег "goodwill", который не используется в оригинальной игре, но читается и даже имеет некий эффект. Это явно как-то связано с отношением собеседника к актору, но прояснить точное влияние до конца не удалось. Если атрибут ставить на фразы актора, то они сортируются по убыванию значения. Выходит как бы фразы с наибольшей доброжелательностью стоят первыми, а с наименьшей (самые недружелюбные) стоят последними. Если ставить атрибут на фразы непися, то эффект неоднозначный. Пока только удалось понять, что если хотя бы одно из значений будет меньше нуля, то будет вылет без лога. А если все больше, то никакого влияния не обнаружено - т.е. фразы выбираются случайно из доступного набора.

Новое в ЗП!!!
тег "script_text", который указывает скриптовую функцию, которая используется для построения текста фразы. Движок вызывает её перед тем, как вывести текст в окне чата. Эта функция должна вернуть строку, и именно эту строку и выведет движок первый раз в списке альтернатив выбора, затем в списке сказанных фраз. Функция должна иметь следующий вид:

function get_text(first_speaker, dialog_id, phrase_id)
    ...
    return <строка для вывода>
end

При этом аргумент second_speaker равен nil, когда фразу произносит актор.

Также в ЗП во фразах встречается тег "is_final" со значением 1. Что это означает - непонятно. Никакого влияния на ход диалога я не обнаружил.

Относительно навигации по графу фраз. Начинается разговор всегда с фразы с идентификатором "0". Кто её скажет, определяется исключительно тем, прописан ли данный диалог стартовым или диалогом актора. Теоретически может быть одновременно и тем и другим. Кто скажет какую фразу после первой определяется простым чередованием. Диалог заканчивается как только сказана фраза, у которой не заданы дальнейшие разветвления. Если разветвления есть, но все оказались отключены предусловиями, то будет вылет.
No available phrase to say
Тег "next" может ссылаться на фразу, сказанную ранее, и таким образом в графе могут быть петли. При этом сохранение той-же очерёдности чередования фраз остаётся исключительно на совести автора диалога. Если, допустим, в примере выше я поставлю в фразу "1_3" ссылку не на "0", а на "1_1", то это создаст ситуацию неоднозначности: Фразу "1_1" скажет второй собеседник, если она следует за "0" и первый, если она следует за "1_3". Технически это будет возможно, хотя почти наверняка неправильно с точки зрения игровой логики (и скорее всего приведёт к косвенным ошибкам).

Во второй части будет подробно описана скриптовая инициализация диалогов, будут рассмотрены все функции и методы, имеющие отношение к диалогам и будет некое количество трёпа на тему построения динамических диалогов.

<!-- id - уникальный в пределах диалога номер фразы --> 
<phrase id="6"> 

<!-- текстовое представление фразы --> 

<text>Sorry, but I have to go.</text> 

<!-- или скриптовая функция которая возвращает строку текста --> 

<script_text>info_test1.test_text</script_text> 

<!-- минимальный уровень благосклонности персонажа, чтоб он смог сказать фразу --> 

<goodwill>60</goodwill> 

<!-- cкриптовые предикаты, если они все вернут true то фраза станет доступной --> 

<precondition>info_test1.test_action</precondition> 

<precondition>info_test1.test_action1</precondition> 

<!-- особые предикаты проверяют наличие/отсутствие порций информации у того кто говорит фразу --> 

<has_info>info_name1</has_info> 

<dont_has_info>info_name1</dont_has_info> 

<!-- cписок тех id фраз которые станут доступны собеседнику после того как будет сказана эта фраза --> 

<next>7</next> 

<next>5</next> 

<!-- cкриптовые функции, которые могут быть вызваны --> 

<action>info_test1.test_action</action> 

<action>info_test1.test_action1</action> 

<!-- особые функции, которые дают/убирают порции информации тому кто говорит фразу --> 

<give_info>info_name1</give_info> 

<disable_info>info_name1</disable_info> 

</phrase>

Все вызываемые скриптовые функции (как action так и precondition) задаются своим ПОЛНЫМ именем: NAMESPACE.FUNC_NAME, NAMESPACE - обычно просто имя файла скрипта с функцией.

Все скриптовые функции получают на вход 2 параметра: собеседник1 и собеседник2. Эти параметры представляют собой объекты персонажей ведущих диалог (актер, сталкеры, торговцы). Причем первым параметром идет тот, кто говорит фразу. (Я не ловил диалога ид, ты уверен в диалоге ида? )

pda="1"/"0" - аттрибут указывающий на то что диалого будет использоваться исключительно при связи по PDA (модеррам билдов. В оффе нету такого.)
priority="-1" - целое число (может быть отрицательным), чем меньше число тем ниже диалог появится при выборе из меню актера

Особой фразой является "пустышка" - фраза в которой отсутствует тег <text>. Фразы - пустышки, полезны, если мы хотим пропустить очередь говорить одного из собеседников. Также с помощью пустышек можно делать стартовые "развилки", то есть нужно сделать возможность начинать диалог не с одной, а со списка различных фраз (в таком случае делается 2 пустышки с id 0 и 1).

Кстати функция возврата строки в диалог, может быть совсем и перемененной.

P.S. Поправь, раскидай, покритикуй (но не сильно бей головой об стену). (Мог что-то повторить) 

Диалоги. Часть вторая - скриптовые диалоги.
Сейчас речь пойдёт о полностью скриптовом создании диалога. Эта возможность реализуется тегом init_func (как показано в примере dialog2 выше).
Напоминаю важнейший факт
Не смотря на то, что при таком способе создание диалога происходит во время выполнения, эту возможность не получится использовать для создания диалогов с графом, изменяющимся в зависимости от собеседника и/или ситуации.
Теги init_func и phrase_list взаимоисключающие. Точнее, при их одновременном наличии тег init_func будет проигнорирован.
Функция, на которую ссылается этот тег должна иметь следующий вид:

function init_dlg(dlg)
    -- здесь создаём диалог
end

где dlg - это объект класса CPhraseDialog. Этот класс выглядит так:

class CPhraseDialog {
    CPhrase* AddPhrase(const char *text, string phrase_id, string prev_phrase_id, int goodwil_level);
};

Т.е. имеет всего один метод AddPhrase. С помощью этого метода можно добавлять в граф диалога новые фразы и связи между ними. Аргументы метода AddPhrase:
text - текст фразы, соответствует тегу text
phrase_id - идентификатор фразы, соответствует атрибуту id тега text.
prev_phrase_id - идентификатор фразы, после которой можно сказать данную. Для первой фразы с идентификатором "0", нужно указать пустую строку "".
goodwil_level - соответствует тегу goodwil

В принципе, этого метода достаточно, чтобы построить простейший диалог. Здесь требуется некоторое пояснение по поводу указания множественных связей между фразами. Если при задании графа через XML во фразе указывались все исходящие из неё фразы, то здесь мы видим иную картину - указывается фраза, для которой исходящей является создаваемая. Может возникнуть вопрос, как при этом задавать ситуацию, когда после нескольких фраз нужно сказать одну и ту-же? В этом случае работает такой принцип: нужно вызвать AddPhrase с одинаковым аргументом phrase_id столько раз, сколько требуется задать входящих связей для фразы с этим идентификатором. При этом создание фразы произойдёт при первом вызове, а при всех последующих будут только добавляться дополнительные входящие связи. При повторных вызовах аргументы text и goodwil_level будут игнорироваться.
Пусть мы хотим задать граф диалога, показанный на рисунке:
Вот функция для создания такого графа:

function init_dlg(dlg)
    dlg:AddPhrase("Starting_phrase_text",    "0", "", -10000) -- корневая фраза
    -- фраза "1_1" - первая альтернатива после фразы "0"
    dlg:AddPhrase("level_1_phrase_text_v1", "1_1", "0", -10000)
    -- фраза "1_2" - вторая альтернатива после фразы "0"
    dlg:AddPhrase("level_1_phrase_text_v2", "1_2", "0", -10000)
    -- фраза "2", идущая после "1_1"
    dlg:AddPhrase("level_2_phrase_text",    "2", "1_1", -10000)
    -- создание дополнительной входящей связи для фразы "2" из фразы "1_2"
    dlg:AddPhrase("",                       "2", "1_2", 0)
end

Функция AddPhrase возвращает объект типа CPhrase.
Описание класса CPhrase:

class CPhrase {
    CPhraseScript* GetPhraseScript();
};

Видно, что у этого класса есть всего один метод, который возвращает объект типа CPhraseScript. С помощью этого объекта можно настроить свойства свежесозданной фразы.
Описание класса CPhraseScript:

class CPhraseScript {
    void SetScriptText(string <имя функции для установки текста фразы>); // только ЧН и ЗП
    void AddPrecondition(string <имя функции предусловия>);
    void AddAction(string <имя функции действия>);
    void AddHasInfo(string <имя инфопорции>);
    void AddDontHasInfo(string <имя инфопорции>);
    void AddGiveInfo(string <имя инфопорции>);
    void AddDisableInfo(string <имя инфопорции>);
};

Названия методов говорят за себя. Смысл тот-же самый, что и у соответствующих настроек в теге phrase. Пользуемся всем этим примерно так:

function init_dlg(dlg)
    ...
    local phrase = dlg:AddPhrase("phrase_text", "123", "23", -10000):GetPhraseScript()
    phrase:AddPrecondition("some_module.some_precondition")
    phrase:AddDisableInfo("some_infoportion")
    -- и т.д.
end

Может возникнуть вопрос, а зачем нужен такой способ создания диалогов, если это не даёт видимых преимуществ перед созданием с помощью XML? Ну, очевидно, без настоящей причины пользоваться этим способом на самом деле смысла нет. Однако в оригинальной игре скриптовое создание диалога используется. Если мы посмотрим, к примеру, диалог dm_hello_dialog (находится в config\gameplay\dialogs.xml), то увидим, что его инициализация происходит в функции dialog_manager.init_intro_dialog. Там, во-первых, используется трюк с пустыми фразами, и первые две фразы таким образом пропускаются. А вот на третьем уровне создаётся множество альтернативных фраз с предусловиями, которые заполняются из таблицы, которая в свою очередь заполняется из файла конфигурации config\misc\dialog_manager.ltx. Т.е. фактически, вместо создания диалога на основе XML реализовано создание на основе ltx. При этом появляются дополнительные возможности, поскольку таблица, на основе которой сделан диалог, осталась в нашем распоряжении (и она используется), и из файла ltx можно читать данные, а из XML нельзя и т.д. По такой же схеме сделаны диалоги торговцев для выдачи заданий.


По диалогам ещё не всё. Остались неохваченными много функций и методов, имеющих отношение к диалогам. Так что будет третья часть.
To be continued... 
Здесь опишу россыпью разные функции, имеющие отношение к управлению диалогами.

Скриптовый старт разговора. Для этого есть метод run_talk_dialog класса game_object. Применим только к актору
db.actor:run_talk_dialog(npc)
где npc - собеседник, с которым надо начать разговор.
Говорить можно со сталкерами и торговцами, из которых в игре есть только Сидор. Разговор можно начать только если собеседник находится на расстоянии не больше трёх метров от актора. Если точнее, то можно попытаться вызвать её и на больших расстояниях. Что-то при этом происходит: появляется мышь, отключается движение актора и он начинает смотреть на "собеседника" даже при том, что окна разговора нет. Такое ощущение, что просто безбожно глючит. Проверка допустимого расстояния перед началом остаётся таким образом на совести скриптёра. Расстояние в 3 метра никакими настройками не изменить, похоже вшито прямо в код движка. Вероятно, если найти и пропатчить это значение, то можно в каком-то смысле вернуть утраченную возможность общаться "через сталкерскую сеть".
Другой момент. Данная функция только открывает диалог разговора. Если не делать ничего дополнительно, то непись "разговаривая" пойдёт себе дальше, и как только выйдет за три метра - разговор прервётся. В игре непись удерживается от убегания специальной скриптовой схемой, которая заставляет его стоять на месте, смотреть на актора, может ещё анимации проигрывать, точно не знаю.

Параметр need_osoznanie_mode в секции персонажа позволяет избежать ограничения в 3 метра на возможность начать разговор. Однако при этом окно разговора показывается не полностью. Отсутствуют окна с иконками собеседников и окно чата. Есть только нижняя часть - окно выбора варианта ответа или диалога. Фактически, это превращает окно общения в своеобразное диалоговое окно для выбора одного из нескольких вариантов. Это используется в игре для предоставления Меченому выбора - присоединяться к О-Сознанию или нет. В принципе ничто не мешает использовать это как-то иначе.

Прервать разговор можно вызвав метод stop_talk для каждого из собеседников. Этот метод используется в специальном диалоге актора, который прописывается каждому NPC. Там есть скриптовое действие, которое выглядит так:

function break_dialog(first_speaker, second_speaker, id)
    first_speaker:stop_talk()
    second_speaker:stop_talk()
end

Ничто не мешает сделать это в любой другой момент.

Из режима разговора можно скриптами переключиться в режим торговли с помощью метода switch_to_trade. Это метод только для актора:
db.actor:switch_to_trade()
Есть и обратный метод switch_to_talk, но он не работает. Т.е. он реально ничего не делает. Там по коду стоит ret и ничего больше. Так что переключиться обратно из торговли в режим разговора можно только закрыв окно мышкой.

// включение/отключение возможности говорить работает только для NPC.
void enable_talk(); // включить возможность говорить
void disable_talk(); // отключить возможность говорить
bool is_talk_enabled(); // возможность говорить
void stop_talk(); // остановить разговор
bool is_talking(); // состояние разговора
Функция is_talking должна возвращать true во время разговора. У меня были случаи, когда она почему-то не срабатывала. Зато железно срабатывают служебные инфопорции на открытие закрытие окна разговора.
Смежные методы для активации окна тороговли
void enable_trade(); // даёт возможность торговать
// торговлю можно запустить если enable_trade() включёно у обоих собеседников
void disable_trade(); // отключить торговлю
bool is_trade_enabled(); // состояние возможности торговать

Функция give_talk_message позволяет в процессе разговора вывести в окно чата сообщение с иконкой. Описание функции:

void give_talk_message( string text, // текст сообшения 
                        string texture_name, // файл с текстурой иконок
                        Frect tex_rect, // прямоугольник иконки в этом файле
                        string templ_name); // имя шаблона

Шаблоны содержатся в XML файле "config\ui\talk.xml" или "config\ui\talk_16.xml" (второй видимо для широких мониторов)
В оригинальной игре есть три шаблона: "iconed_answer_item", "actor_answer_item" и "iconed_trade_info". Если не задать никакой, то используется "iconed_answer_item". В принципе, ничто не мешает добавить в этот файл свои шаблоны. Можно поменять размеры иконки и свойства текста.
Предназначении этой функции в оригинальной игре - вывод дополнительных строк в диалоге при реализации динамического списка предлагаемых квестов. Как всегда, извращённый разум модостроителя может найти ей и иные применения. К примеру, если убрать иконку и сделать текст надписи похожим на текст основного чата, то можно с помощью тега action и этой функции частично реализовать функциональность отсутствующего в ТЧ тега script_text.

Функции, работающие только для неписей:
void set_start_dialog(string <dialog_id>) // установка приветственного диалога NPC
void restore_default_start_dialog() // восстановление диалога, заданного в профиле персонажа
void get_start_dialog() // функция по смыслу должна возвращать строку - имя стартового диалога, но на самом деле не делает ничего.

Изменённое имя стартового диалога запоминается и при загрузке восстанавливается.

Набор диалогов актора складывается из диалогов актора, прописанных в профиле персонажа и переданных персонажу с инфопорцими. Диалоги, переданные с инфопорциями, запоминаются и восстанавливаются после сохранения. У актора никаких диалогов нет и передача диалогов с инфопорциями для актора не работает. Если надо прописать какой-то диалог всем неписям, то это можно сделать в биндере сталкеров (поскольку он у всех сталкеров общий).


Дополнение о создании динамических диалогов
В заключение диалогов немного рассуждений о стратегии построения динамических диалогов. Под динамическими я разумею такие диалоги, где что-то меняется в зависимости от ситуации (к примеру, в зависимости от ранее сказанного). Менять в принципе хотелось бы граф фраз и текст фраз. Если вы ещё не забыли, то напоминаю, что невозможно изменить полный граф отдельно взятого диалога. Надеюсь, вы также не забыли, чем отличается диалог от разговора. Кроме того, очевидно для NPC и для актора подходы к реализации динамических диалогов могут отличаться.
Начнём с NPC. Допустим актор сказал некую фразу, и надо, чтобы ответ зависел от того, что было сказано, и вообще от текущих игровых обстоятельств любого свойства. Большим преимуществом является то, что вне зависимости от способа генерации ответа это происходит невидимо для актора. В любом случае виден будет только результат - сказанная фраза. Это существенно расширяет арсенал подходов к решению данной задачи.
Самый незатейливый подход - это просто создать несколько (возможно даже очень много) заранее готовых вариантов ответа и настроить выбор подходящего ответа с помощью предусловий. Этот способ работает в подавляющем большинстве случаев, для него есть готовые средства в виде предусловий по инфопорциям и скриптовых предусловий. Недостаток этого способа - фиксированный текст фраз. Если надо сделать вариабельный текст, то придётся создавать много вариантов, отличающихся, быть может, на пару символов.
Второй подход подразумевает всего одну исходящую ветку графа, но при этом текст ответа должен так или иначе генерироваться "на лету". Собственно, именно для этого есть тег script_text, который был в ранних билдах, был убран в релизе ТЧ и опять появился в ЧН/ЗП. С помощью этого тега можно задать функцию, а в ней уже по обстоятельствам сгенерировать текст ответа. Увы, в ТЧ это не работает, а этот движок пока является наиболее актуальным. Выкрутиться из положения можно с помощью функции give_talk_message. Можно задать основной текст ответа пустым, задать тег action, а в нём вызвать эту функцию для вывода произвольного текста. Надо только подрихтовать шаблон для этой функции так, чтобы её вывод был похож на основной текст чата.
Ничто не мешает при этом комбинировать все способы: задавать варианты с предусловиями и при этом генерировать текст полностью или частично, дополняя заранее заданный.

Для актора всё и сложнее и проще. Проще, поскольку как правило от актора и не требуется большой вариабельности в ответах: да/нет, спасибо/до свидания, т.е. ведущая роль принадлежит NPC. Сложнее потому, что для актора не всё из сказанного ранее работает. Отличие ответа актора от ответат NPC в том, что игрок выбирает ответ. При этом есть текст, который виден в окне выбора ответа и есть текст, который появится в окне списка сказанных фраз. Функция из тега script_text устанавливает и тот и другой текст, но под ТЧ это работать не будет. give_talk_message никак не меняет текст в окне выбора. Более того, не получится сделать текст фразы пустым, как это можно было сделать для фразы NPC. Дело в том, что пустая фраза будет просто пропущена движком. Если же задать текст фразы, то в окне чата появится этот текст и то, что выведет give_talk_message, в придачу. Ясно, что далеко не во всех случаях это будет приемлемо.
Возможный, хотя тоже ограниченный, подход может быть такой. Можно после фразы NPC завершать диалог. При этом окно разговора переходит в режим выбора другого диалога. Но внешне это практически никак не отличается от режима выбора фразы. Однако, при этом появляется дополнительная возможность в виде атрибута диалога caption, который может маскировать первую фразу диалога. Фраза при этом может быть и пустая, что даёт возможность сгенерировать её текст целиком с помощью give_talk_message. Выбор фразы при таком подходе будет осуществляться с помощью выбора диалога. Ясно, что придётся выкручиваться с заголовками диалогов (как бы фразами), делая их максимально универсальными. Например, сделать заголовок диалога "назвать свою цену", а уже в сказанной фразе показать собственно цену, которая будет сгенерирована на лету.


